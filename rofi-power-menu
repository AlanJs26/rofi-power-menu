#!/usr/bin/env bash

# This script defines just a mode for rofi instead of being a self-contained
# executable that launches rofi by itself. This makes it more flexible than
# running rofi inside this script as now the user can call rofi as one pleases.
# For instance:
#
#   rofi -show powermenu -modi powermenu:./rofi-power-menu
#
# See README.md for more information.

lockscreen="Lock screen"
switchuser="Switch user"
logout="Log out"
suspend="Suspend"
hibernate="Hibernate"
reboot="Reboot"
shutdown="Shut down"

# Ask for confirmation for actions that are irreversible
confirmReboot="Yes, reboot"
confirmShutdown="Yes, shut down"
confirmLogout="Yes, log out"
cancel="No, cancel"

# Default options
show="$shutdown\n$reboot\n$suspend\n$hibernate\n$logout\n$lockscreen\n"
confirm=false
dryrun=false

# Parse command-line options
parsed=$(getopt --options="" --longoptions=dry-run,confirm,options: --name "$0" -- "$@")
if [ $? -ne 0 ]; then
    echo 'Terminating...' >&2
    exit 1
fi
eval set -- "$parsed"
unset parsed
while true; do
    case "$1" in
        "--dry-run")
            dryrun=true
            shift 1
            continue
            ;;
        "--confirm")
            confirm=true
            shift 1
            continue
            ;;
        "--options")
            IFS='/' read -ra options <<< "$2"
            show=""
            for option in "${options[@]}"; do
                case $option in
                    "lockscreen")
                        show="$show$lockscreen\n" ;;
                    "logout")
                        show="$show$logout\n" ;;
                    "suspend")
                        show="$show$suspend\n" ;;
                    "hibernate")
                        show="$show$hibernate\n" ;;
                    "reboot")
                        show="$show$reboot\n" ;;
                    "shutdown")
                        show="$show$shutdown\n" ;;
                    *)
                        echo "Invalid option: $option" >&2
                        exit 1
                        ;;
                esac
            done
            shift 2
            continue
            ;;
        "--")
            shift
            break
            ;;
        *)
            echo "Internal error" >&2
            exit 1
            ;;
    esac
done

if [ -z "$1" ]
then
    printf "$show"
else
    selection=$@
    case $selection in
        $lockscreen)
            if [ $dryrun = true ]
            then
                echo "Locking screen.." >&2
            else
                loginctl lock-session $XDG_SESSION_ID &> /dev/null
            fi
            ;;
        $switchuser)
            # TODO: I suppose this is window manager dependent?
            echo "User switching not implemented yet" >&2
            ;;
        $logout)
            if [ $confirm = true ]
            then
                confirmed=false
                echo $confirmLogout
                echo $cancel
                exit 0
            fi
            ;&  # resume to the next case
        $confirmLogout)
            if [ $dryrun = true ]
            then
                echo "Logging out.." >&2
            else
                loginctl terminate-session $XDG_SESSION_ID &> /dev/null
            fi
            ;;
        $suspend)
            if [ $dryrun = true ]
            then
                echo "Suspending.." >&2
            else
                systemctl suspend &> /dev/null
            fi
            ;;
        $hibernateConfirmation)
            if [ $dryrun = true ]
            then
                echo "Hibernating.." >&2
            else
                systemctl hibernate &> /dev/null
            fi
            ;;
        $reboot)
            if [ $confirm = true ]
            then
                confirmed=false
                echo $confirmReboot
                echo $cancel
                exit 0
            fi
            ;&  # resume to the next case
        $confirmReboot)
            if [ $dryrun = true ]
            then
                echo "Rebooting.." >&2
            else
                systemctl reboot &> /dev/null
            fi
            ;;
        $shutdown)
            if [ $confirm = true ]
            then
                confirmed=false
                echo $confirmShutdown
                echo $cancel
                exit 0
            fi
            ;&  # resume to the next case
        $confirmShutdown)
            if [ $dryrun = true ]
            then
                echo "Shutting down.." >&2
            else
                systemctl poweroff &> /dev/null
            fi
            ;;
        $cancel)
            exit 0
            ;;
        *)
            >&2 echo "Invalid choice."
            exit 1
            ;;
    esac
fi
